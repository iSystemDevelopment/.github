name: 'Bug Report Tracker and Auto-Fix'

on:
  issues:
    types: [opened, labeled, reopened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read
  pull-requests: write

jobs:
  track-and-analyze:
    name: Track Bug Report and Analyze
    if: contains(github.event.issue.labels.*.name, 'bug') || startsWith(github.event.issue.title, '[Bug]')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
        with:
          persist-credentials: false

      - name: Analyze and Categorize Bug
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const issueBody = issue.body || '';
            const issueTitle = issue.title || '';
            
            console.log(`Analyzing bug report #${issueNumber}: ${issueTitle}`);
            
            // Initialize bug tracking data
            const bugData = {
              number: issueNumber,
              title: issueTitle,
              reportedAt: issue.created_at,
              severity: 'unknown',
              category: 'unknown',
              status: 'needs-triage',
              reproducible: false,
              hasEnvironmentInfo: false,
              hasSolution: false
            };
            
            // Analyze severity based on keywords
            const criticalKeywords = ['crash', 'data loss', 'security', 'corrupt', 'cannot start', 'fatal'];
            const highKeywords = ['broken', 'not working', 'fails', 'error', 'exception', 'hang'];
            const mediumKeywords = ['incorrect', 'unexpected', 'slow', 'performance'];
            const lowKeywords = ['typo', 'ui', 'cosmetic', 'minor'];
            
            const lowerTitle = issueTitle.toLowerCase();
            const lowerBody = issueBody.toLowerCase();
            const combinedText = lowerTitle + ' ' + lowerBody;
            
            if (criticalKeywords.some(keyword => combinedText.includes(keyword))) {
              bugData.severity = 'critical';
            } else if (highKeywords.some(keyword => combinedText.includes(keyword))) {
              bugData.severity = 'high';
            } else if (mediumKeywords.some(keyword => combinedText.includes(keyword))) {
              bugData.severity = 'medium';
            } else if (lowKeywords.some(keyword => combinedText.includes(keyword))) {
              bugData.severity = 'low';
            }
            
            // Categorize bug type
            if (combinedText.includes('security') || combinedText.includes('vulnerability')) {
              bugData.category = 'security';
            } else if (combinedText.includes('performance') || combinedText.includes('slow')) {
              bugData.category = 'performance';
            } else if (combinedText.includes('ui') || combinedText.includes('interface')) {
              bugData.category = 'ui';
            } else if (combinedText.includes('api') || combinedText.includes('endpoint')) {
              bugData.category = 'api';
            } else if (combinedText.includes('database') || combinedText.includes('data')) {
              bugData.category = 'database';
            } else {
              bugData.category = 'general';
            }
            
            // Check if reproduction steps are provided
            bugData.reproducible = issueBody.includes('Steps to Reproduce') || 
                                   issueBody.includes('To Reproduce') ||
                                   /\d+\.\s+/.test(issueBody);
            
            // Check if environment info is provided
            bugData.hasEnvironmentInfo = issueBody.includes('Environment') ||
                                         issueBody.includes('OS:') ||
                                         issueBody.includes('Browser:') ||
                                         issueBody.includes('Version:');
            
            // Add appropriate labels
            const labelsToAdd = [];
            
            if (bugData.severity !== 'unknown') {
              labelsToAdd.push(`severity: ${bugData.severity}`);
            }
            
            if (bugData.category !== 'unknown') {
              labelsToAdd.push(`category: ${bugData.category}`);
            }
            
            if (!bugData.reproducible) {
              labelsToAdd.push('needs-reproduction-steps');
            }
            
            if (!bugData.hasEnvironmentInfo) {
              labelsToAdd.push('needs-environment-info');
            }
            
            // Apply labels
            if (labelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labelsToAdd
                });
                console.log(`Added labels: ${labelsToAdd.join(', ')}`);
              } catch (error) {
                console.log(`Note: Some labels may need to be created first: ${labelsToAdd.join(', ')}`);
              }
            }
            
            // Generate automated analysis comment
            let analysisComment = `## ü§ñ Automated Bug Analysis\n\n`;
            analysisComment += `**Bug Report #${issueNumber}** has been received and analyzed.\n\n`;
            analysisComment += `### Analysis Summary\n\n`;
            analysisComment += `| Attribute | Value |\n`;
            analysisComment += `|-----------|-------|\n`;
            analysisComment += `| **Severity** | ${bugData.severity.toUpperCase()} |\n`;
            analysisComment += `| **Category** | ${bugData.category} |\n`;
            analysisComment += `| **Reproducible** | ${bugData.reproducible ? '‚úÖ Yes' : '‚ùå Missing steps'} |\n`;
            analysisComment += `| **Environment Info** | ${bugData.hasEnvironmentInfo ? '‚úÖ Provided' : '‚ùå Missing'} |\n`;
            analysisComment += `| **Status** | ${bugData.status} |\n\n`;
            
            // Add recommendations
            analysisComment += `### üìã Recommendations\n\n`;
            
            if (!bugData.reproducible) {
              analysisComment += `- ‚ö†Ô∏è **Missing Reproduction Steps**: Please provide detailed steps to reproduce the issue.\n`;
            }
            
            if (!bugData.hasEnvironmentInfo) {
              analysisComment += `- ‚ö†Ô∏è **Missing Environment Info**: Please provide your OS, browser, and version information.\n`;
            }
            
            if (bugData.severity === 'critical') {
              analysisComment += `- üö® **Critical Priority**: This issue requires immediate attention.\n`;
            }
            
            if (bugData.category === 'security') {
              analysisComment += `- üîí **Security Issue**: Please verify this should not be reported via our security policy.\n`;
            }
            
            analysisComment += `\n### üîß Suggested Actions\n\n`;
            
            // Provide category-specific suggestions
            switch (bugData.category) {
              case 'security':
                analysisComment += `1. Review security policy compliance\n`;
                analysisComment += `2. Assess impact and affected versions\n`;
                analysisComment += `3. Develop security patch\n`;
                analysisComment += `4. Test thoroughly in isolated environment\n`;
                break;
              case 'performance':
                analysisComment += `1. Profile the application to identify bottlenecks\n`;
                analysisComment += `2. Review database queries and indexes\n`;
                analysisComment += `3. Check for memory leaks\n`;
                analysisComment += `4. Consider caching strategies\n`;
                break;
              case 'ui':
                analysisComment += `1. Verify UI component behavior\n`;
                analysisComment += `2. Test across different browsers/devices\n`;
                analysisComment += `3. Review CSS and responsive design\n`;
                analysisComment += `4. Check accessibility standards\n`;
                break;
              case 'api':
                analysisComment += `1. Review API endpoint logic\n`;
                analysisCommand += `2. Check request/response validation\n`;
                analysisComment += `3. Verify authentication and authorization\n`;
                analysisComment += `4. Review error handling\n`;
                break;
              default:
                analysisComment += `1. Review related code sections\n`;
                analysisComment += `2. Add unit tests to reproduce the issue\n`;
                analysisComment += `3. Implement fix with proper error handling\n`;
                analysisComment += `4. Test thoroughly before deployment\n`;
            }
            
            analysisComment += `\n### üìä Bug Tracking\n\n`;
            analysisComment += `This bug is now being tracked. Updates will be provided as investigation progresses.\n\n`;
            analysisComment += `**Next Steps:**\n`;
            analysisComment += `- Maintainers will review and triage\n`;
            analysisComment += `- Additional information may be requested\n`;
            analysisComment += `- Fix priority will be assigned based on severity\n\n`;
            analysisComment += `---\n`;
            analysisComment += `*This analysis was automatically generated by the Bug Tracker workflow.*`;
            
            // Post analysis comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: analysisComment
            });
            
            console.log('Bug analysis completed and posted.');
            
            // Store analysis data as artifact (for reporting)
            core.setOutput('bug-data', JSON.stringify(bugData, null, 2));
            core.setOutput('severity', bugData.severity);
            core.setOutput('category', bugData.category);

      - name: Generate Bug Report Summary
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const issue = context.payload.issue;
            
            // Create a summary report
            const report = `
            # Bug Report Summary - Issue #${issue.number}
            
            **Title:** ${issue.title}
            **Reported by:** @${issue.user.login}
            **Reported at:** ${issue.created_at}
            **URL:** ${issue.html_url}
            
            ## Status
            - ‚úÖ Bug report received and logged
            - ‚úÖ Automated analysis completed
            - ‚úÖ Labels applied
            - ‚úÖ Tracking initiated
            
            ## Analysis Complete
            The bug has been analyzed and categorized. Maintainers have been notified.
            
            **Report ID:** ${issue.number}-${Date.now()}
            `;
            
            console.log(report);
            console.log('\n‚úÖ Bug tracking and analysis completed successfully.');

  create-tracking-report:
    name: Create Bug Tracking Report
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'reopened')
    runs-on: ubuntu-latest
    needs: track-and-analyze
    
    steps:
      - name: Generate Summary Report
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const issue = context.payload.issue;
            
            console.log('='.repeat(80));
            console.log('BUG TRACKING REPORT');
            console.log('='.repeat(80));
            console.log(`Issue Number: #${issue.number}`);
            console.log(`Issue Title: ${issue.title}`);
            console.log(`Reporter: @${issue.user.login}`);
            console.log(`Created: ${issue.created_at}`);
            console.log(`Status: Tracked and Analyzed`);
            console.log('='.repeat(80));
            console.log('\n‚úÖ Bug report has been successfully tracked and analyzed.');
            console.log('‚úÖ Automated categorization and labeling completed.');
            console.log('‚úÖ Analysis posted to issue thread.');
            console.log('\nMaintainers can now review and proceed with fixes.');
